name: AutoDev - Autonomous Development Workflow

on:
  issues:
    types: [assigned, labeled]
  issue_comment:
    types: [created]
  pull_request:
    types: [opened, synchronize, reopened]

env:
  AUTODEV_API_URL: http://localhost:8002

jobs:
  # Job 1: Plan Feature (Gemini PRD Agent)
  plan_feature:
    name: Generate Development Plan
    if: |
      github.event_name == 'issues' &&
      github.event.issue.assignee &&
      contains(github.event.issue.labels.*.name, 'autodev')
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          pip install httpx pydantic

      - name: Generate Development Plan
        id: generate_plan
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
          ISSUE_TITLE: ${{ github.event.issue.title }}
          ISSUE_BODY: ${{ github.event.issue.body }}
        run: |
          python << 'EOF'
          import httpx
          import json
          import os

          issue_number = os.environ['ISSUE_NUMBER']
          issue_title = os.environ['ISSUE_TITLE']
          issue_body = os.environ['ISSUE_BODY']

          # Call AutoDev API to generate PRD
          async def generate_prd():
              async with httpx.AsyncClient(timeout=120.0) as client:
                  response = await client.post(
                      f"{os.environ['AUTODEV_API_URL']}/api/v1/autodev/prd/generate",
                      json={
                          "title": issue_title,
                          "description": issue_body,
                          "requirements": [],
                          "context": f"GitHub Issue #{issue_number}"
                      }
                  )
                  return response.json()

          import asyncio
          result = asyncio.run(generate_prd())

          # Save plan to file
          with open('autodev_plan.json', 'w') as f:
              json.dump(result, f, indent=2)

          print(f"Plan generated successfully")
          EOF

      - name: Create Development Plan Comment
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const plan = JSON.parse(fs.readFileSync('autodev_plan.json', 'utf8'));

            const prd = plan.result?.prd || {};

            const comment = `## 🤖 AutoDev Development Plan Generated

            **Issue**: #${{ github.event.issue.number }} - ${{ github.event.issue.title }}
            **Agent**: PRD Agent (Gemini 2.0 Flash Thinking)
            **Confidence**: ${plan.confidence || 0.85}

            ### 📋 Executive Summary
            ${prd.executive_summary || 'N/A'}

            ### 🎯 Problem Statement
            ${prd.problem_statement || 'N/A'}

            ### 📝 User Stories
            ${prd.user_stories?.map((story, i) =>
              `${i+1}. **[${story.priority}]** As a ${story.user}, I want ${story.action}, so that ${story.benefit}`
            ).join('\n') || 'N/A'}

            ### ✅ Acceptance Criteria
            ${prd.acceptance_criteria?.slice(0, 3).map(ac =>
              `**Scenario**: ${ac.scenarios?.[0]?.scenario_name || 'N/A'}\n` +
              `- Given: ${ac.scenarios?.[0]?.given?.join(', ') || 'N/A'}\n` +
              `- When: ${ac.scenarios?.[0]?.when?.join(', ') || 'N/A'}\n` +
              `- Then: ${ac.scenarios?.[0]?.then?.join(', ') || 'N/A'}`
            ).join('\n\n') || 'N/A'}

            ### 📊 Success Metrics
            ${prd.success_metrics?.map(m =>
              `- **${m.metric}**: ${m.target} (${m.measurement})`
            ).join('\n') || 'N/A'}

            ### 🚀 Timeline
            - Planning: ${prd.timeline?.planning || 'TBD'}
            - Development: ${prd.timeline?.development || 'TBD'}
            - Testing: ${prd.timeline?.testing || 'TBD'}
            - Deployment: ${prd.timeline?.deployment || 'TBD'}

            ---

            **To proceed with implementation**, comment:
            \`\`\`
            /autodev implement
            \`\`\`

            **To refine the plan**, comment:
            \`\`\`
            /autodev refine [your feedback]
            \`\`\`

            🤖 Generated by AutoDev System
            `;

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: ${{ github.event.issue.number }},
              body: comment
            });

  # Job 2: Implement Feature (Claude Code Agent)
  implement_feature:
    name: Implement Feature
    if: |
      github.event_name == 'issue_comment' &&
      github.event.issue.state == 'open' &&
      contains(github.event.comment.body, '/autodev implement')
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          pip install httpx pydantic

      - name: Extract Development Plan
        id: extract_plan
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });

            const planComment = comments.data.find(c =>
              c.body.includes('AutoDev Development Plan Generated')
            );

            if (planComment) {
              const fs = require('fs');
              fs.writeFileSync('plan.md', planComment.body);
              return { found: true };
            }
            return { found: false };

      - name: Execute Implementation
        if: steps.extract_plan.outputs.found == 'true'
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
        run: |
          python << 'EOF'
          import httpx
          import json
          import os
          import asyncio

          async def implement():
              async with httpx.AsyncClient(timeout=300.0) as client:
                  # Call feature development workflow
                  response = await client.post(
                      f"{os.environ['AUTODEV_API_URL']}/api/v1/autodev/workflows/feature-development",
                      json={
                          "issue_number": int(os.environ['ISSUE_NUMBER']),
                          "issue_title": "${{ github.event.issue.title }}",
                          "issue_body": "${{ github.event.issue.body }}",
                          "context": {
                              "repository": "${{ github.repository }}",
                              "branch": "${{ github.ref }}"
                          }
                      }
                  )
                  result = response.json()

                  with open('implementation.json', 'w') as f:
                      json.dump(result, f, indent=2)

                  return result

          result = asyncio.run(implement())
          print(f"Implementation completed: {result.get('overall_status')}")
          EOF

      - name: Commit and Push Changes
        run: |
          git config user.name "AutoDev Bot"
          git config user.email "autodev@nerdx.app"
          git checkout -b autodev/issue-${{ github.event.issue.number }}
          git add .
          git commit -m "feat: implement issue #${{ github.event.issue.number }}

          ${{ github.event.issue.title }}

          🤖 Generated by AutoDev System (Claude Code Agent)

          Co-Authored-By: AutoDev <autodev@nerdx.app>"
          git push origin autodev/issue-${{ github.event.issue.number }}

      - name: Create Pull Request
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const implementation = JSON.parse(fs.readFileSync('implementation.json', 'utf8'));

            const body = `## 🤖 AutoDev Implementation Complete

            **Closes**: #${{ github.event.issue.number }}
            **Workflow**: Feature Development
            **Status**: ${implementation.overall_status || 'completed'}

            ### 📊 Implementation Summary

            #### Steps Completed
            ${implementation.results?.steps?.map((step, i) =>
              `${i+1}. **${step.step}**: ${step.status}`
            ).join('\n') || 'N/A'}

            #### Code Changes
            - Files modified/created: ${implementation.results?.implementation?.file_changes?.length || 0}
            - Tests generated: ${implementation.results?.implementation?.tests_created?.length || 0}
            - Test coverage: ${implementation.results?.test_results?.coverage || 'N/A'}

            #### Code Review Results
            ${implementation.results?.claude_review ? `
            **Claude Review (Plan Adherence)**:
            - Plan adherence: ${implementation.results.claude_review.review?.plan_adherence_score || 'N/A'}/10
            - Logic correctness: ${implementation.results.claude_review.review?.logic_correctness_score || 'N/A'}/10
            ` : ''}

            ${implementation.results?.gemini_review ? `
            **Gemini Review (Maintainability & Security)**:
            - Maintainability: ${implementation.results.gemini_review.review?.maintainability_score || 'N/A'}/10
            - Security: ${implementation.results.gemini_review.review?.security_score || 'N/A'}/10
            ` : ''}

            #### Quality Gates
            ${implementation.results?.quality_gates?.overall_passed ? '✅ PASSED' : '❌ FAILED'}

            ---

            🤖 Generated by AutoDev System
            - PRD Agent (Gemini 2.0 Flash Thinking)
            - Code Agent (Claude Sonnet 4.5)
            - QA Agent (Multi-agent Review)
            `;

            const pr = await github.rest.pulls.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `feat: ${{ github.event.issue.title }}`,
              head: `autodev/issue-${{ github.event.issue.number }}`,
              base: 'main',
              body: body
            });

            console.log(`PR created: ${pr.data.html_url}`);

  # Job 3: Quality Gate (Multi-Agent Review + Tools)
  quality_gate:
    name: Quality Gate Validation
    if: |
      github.event_name == 'pull_request' &&
      startsWith(github.head_ref, 'autodev/')
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      checks: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          pip install httpx pydantic

      - name: Get PR Diff
        id: get_diff
        run: |
          git fetch origin ${{ github.base_ref }}
          git diff origin/${{ github.base_ref }}...HEAD > pr_diff.txt
          echo "diff_file=pr_diff.txt" >> $GITHUB_OUTPUT

      - name: Multi-Agent Code Review
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          python << 'EOF'
          import httpx
          import json
          import os
          import asyncio

          async def review():
              with open('pr_diff.txt', 'r') as f:
                  diff = f.read()

              async with httpx.AsyncClient(timeout=180.0) as client:
                  response = await client.post(
                      f"{os.environ['AUTODEV_API_URL']}/api/v1/autodev/qa/multi-agent-review",
                      json={
                          "pr_number": ${{ github.event.pull_request.number }},
                          "diff": diff,
                          "plan": {},
                          "review_aspects": ["all"]
                      }
                  )
                  result = response.json()

                  with open('review.json', 'w') as f:
                      json.dump(result, f, indent=2)

                  return result

          result = asyncio.run(review())
          print(f"Review completed: {result.get('result', {}).get('approval', False)}")
          EOF

      - name: Run Quality Gates
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        run: |
          python << 'EOF'
          import httpx
          import json
          import os
          import asyncio

          async def quality_gates():
              async with httpx.AsyncClient(timeout=300.0) as client:
                  response = await client.post(
                      f"{os.environ['AUTODEV_API_URL']}/api/v1/autodev/qa/quality-gates",
                      json={
                          "target": ".",
                          "gates": ["sonarqube", "snyk", "coverage"]
                      }
                  )
                  result = response.json()

                  with open('quality_gates.json', 'w') as f:
                      json.dump(result, f, indent=2)

                  return result

          result = asyncio.run(quality_gates())
          print(f"Quality gates: {result.get('result', {}).get('overall_passed', False)}")
          EOF

      - name: Post Review Comment
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const review = JSON.parse(fs.readFileSync('review.json', 'utf8'));
            const gates = JSON.parse(fs.readFileSync('quality_gates.json', 'utf8'));

            const reviewResult = review.result || {};
            const gatesResult = gates.result || {};

            const comment = `## 🤖 AutoDev Quality Gate Report

            ### 👥 Multi-Agent Code Review

            **Claude Review (Plan Adherence & Logic)**:
            - Overall Assessment: ${reviewResult.claude_review?.review?.overall_assessment || 'N/A'}
            - Plan Adherence: ${reviewResult.claude_review?.review?.plan_adherence_score || 'N/A'}/10
            - Logic Correctness: ${reviewResult.claude_review?.review?.logic_correctness_score || 'N/A'}/10

            **Gemini Review (Maintainability & Security)**:
            - Overall Assessment: ${reviewResult.gemini_review?.review?.overall_assessment || 'N/A'}
            - Maintainability: ${reviewResult.gemini_review?.review?.maintainability_score || 'N/A'}/10
            - Security: ${reviewResult.gemini_review?.review?.security_score || 'N/A'}/10

            **Combined Review**:
            - Overall Score: ${reviewResult.combined_review?.overall_score || 'N/A'}/10
            - Approval Status: ${reviewResult.approval ? '✅ APPROVED' : '❌ CHANGES REQUESTED'}
            - Reason: ${reviewResult.approval_reason || 'N/A'}

            ### 🚦 Quality Gates

            ${gatesResult.overall_passed ? '✅ ALL GATES PASSED' : '❌ SOME GATES FAILED'}

            **SonarQube AI Code Assurance**:
            ${gatesResult.gates?.sonarqube?.passed ? '✅' : '❌'} ${gatesResult.gates?.sonarqube?.passed ? 'PASSED' : 'FAILED'}
            - Coverage: ${gatesResult.gates?.sonarqube?.results?.new_coverage * 100 || 'N/A'}%
            - Duplication: ${gatesResult.gates?.sonarqube?.results?.new_duplication * 100 || 'N/A'}%
            - Security Rating: ${gatesResult.gates?.sonarqube?.results?.security_rating || 'N/A'}

            **Snyk Security Scan**:
            ${gatesResult.gates?.snyk?.passed ? '✅' : '❌'} ${gatesResult.gates?.snyk?.passed ? 'PASSED' : 'FAILED'}
            - Critical: ${gatesResult.gates?.snyk?.results?.critical_vulnerabilities || 0}
            - High: ${gatesResult.gates?.snyk?.results?.high_vulnerabilities || 0}

            **Test Coverage**:
            ${gatesResult.gates?.coverage?.passed ? '✅' : '❌'} ${gatesResult.gates?.coverage?.passed ? 'PASSED' : 'FAILED'}
            - Coverage: ${gatesResult.gates?.coverage?.results?.new_code_coverage * 100 || 'N/A'}%

            ---

            ${reviewResult.approval && gatesResult.overall_passed ?
              '✅ **READY TO MERGE** - All checks passed!' :
              '⚠️ **ACTION REQUIRED** - Please address the issues above.'}

            🤖 Generated by AutoDev Quality Gate System
            `;

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: ${{ github.event.pull_request.number }},
              body: comment
            });

            // Set PR status
            if (!reviewResult.approval || !gatesResult.overall_passed) {
              throw new Error('Quality gate failed');
            }

  # Job 4: E2E Test Generation and Execution
  e2e_test:
    name: E2E Test Generation
    if: |
      github.event_name == 'pull_request' &&
      github.event.pull_request.base.ref == 'staging'
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          pip install httpx pydantic
          npm install
          npx playwright install

      - name: Generate E2E Tests
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          python << 'EOF'
          import httpx
          import json
          import os
          import asyncio

          async def generate_e2e():
              # Get acceptance criteria from PR description
              acceptance_criteria = []  # Extract from PR

              async with httpx.AsyncClient(timeout=180.0) as client:
                  response = await client.post(
                      f"{os.environ['AUTODEV_API_URL']}/api/v1/autodev/qa/generate-e2e-tests",
                      json={
                          "acceptance_criteria": acceptance_criteria,
                          "framework": "playwright",
                          "platform": "web"
                      }
                  )
                  result = response.json()

                  with open('e2e_tests.json', 'w') as f:
                      json.dump(result, f, indent=2)

                  return result

          result = asyncio.run(generate_e2e())
          print(f"E2E tests generated: {result.get('result', {}).get('scenarios_covered', 0)} scenarios")
          EOF

      - name: Run E2E Tests
        run: |
          npx playwright test

      - name: Upload Test Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-report
          path: playwright-report/
